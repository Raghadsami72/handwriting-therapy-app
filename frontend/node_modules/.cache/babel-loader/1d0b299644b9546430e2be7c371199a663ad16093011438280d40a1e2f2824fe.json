{"ast":null,"code":"// âœ… Cleaned and fixed tracking_agent/index.js for full stroke tracking\nlet strokes = []; // All points across all strokes\nlet currentStroke = []; // Single stroke (list of enriched points)\nlet sessionMeta = {\n  patientName: \"Anonymous\",\n  sessionId: \"\"\n};\nexport function startTracking({\n  patientName = \"Anonymous\",\n  sessionId = \"\"\n}) {\n  sessionMeta = {\n    patientName,\n    sessionId\n  };\n  strokes = [];\n  currentStroke = [];\n  console.log(\"ðŸ§  Tracking started for\", patientName);\n}\nexport function recordStrokePoint(point) {\n  var _point$pressure;\n  currentStroke.push({\n    x: point.x,\n    y: point.y,\n    timestamp: point.timestamp,\n    pressure: (_point$pressure = point.pressure) !== null && _point$pressure !== void 0 ? _point$pressure : 0.5\n  });\n}\nexport function finalizeStroke() {\n  if (currentStroke.length > 0) {\n    strokes.push(...currentStroke);\n    currentStroke = [];\n  }\n}\nexport async function endTracking({\n  generateJSON = true,\n  autoDownloadLog = true\n}) {\n  finalizeStroke();\n  const result = {\n    patientName: sessionMeta.patientName,\n    sessionId: sessionMeta.sessionId,\n    timestamp: new Date().toISOString(),\n    strokeCount: strokes.length,\n    strokes\n  };\n  console.log(\"ðŸ“ˆ Session Stroke Data:\", result);\n  if (generateJSON && autoDownloadLog) {\n    const blob = new Blob([JSON.stringify(result, null, 2)], {\n      type: \"application/json\"\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement(\"a\");\n    a.href = url;\n    a.download = `${sessionMeta.patientName}_tracking_log.json`;\n    a.click();\n    URL.revokeObjectURL(url);\n  }\n  return result;\n}\n//this function is used to end the tracking session and generate a JSON report of the strokes recorded during the session. \n// It also handles the download of the JSON file if specified.\n// The function takes an object with options for generating the JSON report and downloading it.\n// It finalizes the current stroke, creates a result object with session metadata and stroke data, and logs it to the console.\n// If the options specify to generate a JSON report and auto-download it, it creates a Blob from the result object, generates a URL for it, and triggers a download of the JSON file with the patient's name and session ID in the filename.\n// Finally, it returns the result object containing the session data.\n// The function is asynchronous, allowing for the use of await when calling it.\n// The function is used to end the tracking session and generate a JSON report of the strokes recorded during the session.","map":{"version":3,"names":["strokes","currentStroke","sessionMeta","patientName","sessionId","startTracking","console","log","recordStrokePoint","point","_point$pressure","push","x","y","timestamp","pressure","finalizeStroke","length","endTracking","generateJSON","autoDownloadLog","result","Date","toISOString","strokeCount","blob","Blob","JSON","stringify","type","url","URL","createObjectURL","a","document","createElement","href","download","click","revokeObjectURL"],"sources":["C:/Users/DELL/Desktop/HandwritingTherapyApp/frontend/src/agents/tracking_agent/index.js"],"sourcesContent":["// âœ… Cleaned and fixed tracking_agent/index.js for full stroke tracking\r\nlet strokes = []; // All points across all strokes\r\nlet currentStroke = []; // Single stroke (list of enriched points)\r\nlet sessionMeta = { patientName: \"Anonymous\", sessionId: \"\" };\r\n\r\nexport function startTracking({ patientName = \"Anonymous\", sessionId = \"\" }) {\r\n  sessionMeta = { patientName, sessionId };\r\n  strokes = [];\r\n  currentStroke = [];\r\n  console.log(\"ðŸ§  Tracking started for\", patientName);\r\n}\r\n\r\nexport function recordStrokePoint(point) {\r\n  currentStroke.push({\r\n    x: point.x,\r\n    y: point.y,\r\n    timestamp: point.timestamp,\r\n    pressure: point.pressure ?? 0.5,\r\n  });\r\n}\r\n\r\nexport function finalizeStroke() {\r\n  if (currentStroke.length > 0) {\r\n    strokes.push(...currentStroke);\r\n    currentStroke = [];\r\n  }\r\n}\r\n\r\nexport async function endTracking({ generateJSON = true, autoDownloadLog = true }) {\r\n  finalizeStroke();\r\n\r\n  const result = {\r\n    patientName: sessionMeta.patientName,\r\n    sessionId: sessionMeta.sessionId,\r\n    timestamp: new Date().toISOString(),\r\n    strokeCount: strokes.length,\r\n    strokes,\r\n  };\r\n\r\n  console.log(\"ðŸ“ˆ Session Stroke Data:\", result);\r\n\r\n  if (generateJSON && autoDownloadLog) {\r\n    const blob = new Blob([JSON.stringify(result, null, 2)], {\r\n      type: \"application/json\",\r\n    });\r\n    const url = URL.createObjectURL(blob);\r\n    const a = document.createElement(\"a\");\r\n    a.href = url;\r\n    a.download = `${sessionMeta.patientName}_tracking_log.json`;\r\n    a.click();\r\n    URL.revokeObjectURL(url);\r\n  }\r\n\r\n  return result;\r\n}\r\n//this function is used to end the tracking session and generate a JSON report of the strokes recorded during the session. \r\n// It also handles the download of the JSON file if specified.\r\n// The function takes an object with options for generating the JSON report and downloading it.\r\n// It finalizes the current stroke, creates a result object with session metadata and stroke data, and logs it to the console.\r\n// If the options specify to generate a JSON report and auto-download it, it creates a Blob from the result object, generates a URL for it, and triggers a download of the JSON file with the patient's name and session ID in the filename.\r\n// Finally, it returns the result object containing the session data.\r\n// The function is asynchronous, allowing for the use of await when calling it.\r\n// The function is used to end the tracking session and generate a JSON report of the strokes recorded during the session."],"mappings":"AAAA;AACA,IAAIA,OAAO,GAAG,EAAE,CAAC,CAAC;AAClB,IAAIC,aAAa,GAAG,EAAE,CAAC,CAAC;AACxB,IAAIC,WAAW,GAAG;EAAEC,WAAW,EAAE,WAAW;EAAEC,SAAS,EAAE;AAAG,CAAC;AAE7D,OAAO,SAASC,aAAaA,CAAC;EAAEF,WAAW,GAAG,WAAW;EAAEC,SAAS,GAAG;AAAG,CAAC,EAAE;EAC3EF,WAAW,GAAG;IAAEC,WAAW;IAAEC;EAAU,CAAC;EACxCJ,OAAO,GAAG,EAAE;EACZC,aAAa,GAAG,EAAE;EAClBK,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEJ,WAAW,CAAC;AACrD;AAEA,OAAO,SAASK,iBAAiBA,CAACC,KAAK,EAAE;EAAA,IAAAC,eAAA;EACvCT,aAAa,CAACU,IAAI,CAAC;IACjBC,CAAC,EAAEH,KAAK,CAACG,CAAC;IACVC,CAAC,EAAEJ,KAAK,CAACI,CAAC;IACVC,SAAS,EAAEL,KAAK,CAACK,SAAS;IAC1BC,QAAQ,GAAAL,eAAA,GAAED,KAAK,CAACM,QAAQ,cAAAL,eAAA,cAAAA,eAAA,GAAI;EAC9B,CAAC,CAAC;AACJ;AAEA,OAAO,SAASM,cAAcA,CAAA,EAAG;EAC/B,IAAIf,aAAa,CAACgB,MAAM,GAAG,CAAC,EAAE;IAC5BjB,OAAO,CAACW,IAAI,CAAC,GAAGV,aAAa,CAAC;IAC9BA,aAAa,GAAG,EAAE;EACpB;AACF;AAEA,OAAO,eAAeiB,WAAWA,CAAC;EAAEC,YAAY,GAAG,IAAI;EAAEC,eAAe,GAAG;AAAK,CAAC,EAAE;EACjFJ,cAAc,CAAC,CAAC;EAEhB,MAAMK,MAAM,GAAG;IACblB,WAAW,EAAED,WAAW,CAACC,WAAW;IACpCC,SAAS,EAAEF,WAAW,CAACE,SAAS;IAChCU,SAAS,EAAE,IAAIQ,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;IACnCC,WAAW,EAAExB,OAAO,CAACiB,MAAM;IAC3BjB;EACF,CAAC;EAEDM,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAEc,MAAM,CAAC;EAE9C,IAAIF,YAAY,IAAIC,eAAe,EAAE;IACnC,MAAMK,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACC,IAAI,CAACC,SAAS,CAACP,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,EAAE;MACvDQ,IAAI,EAAE;IACR,CAAC,CAAC;IACF,MAAMC,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACP,IAAI,CAAC;IACrC,MAAMQ,CAAC,GAAGC,QAAQ,CAACC,aAAa,CAAC,GAAG,CAAC;IACrCF,CAAC,CAACG,IAAI,GAAGN,GAAG;IACZG,CAAC,CAACI,QAAQ,GAAG,GAAGnC,WAAW,CAACC,WAAW,oBAAoB;IAC3D8B,CAAC,CAACK,KAAK,CAAC,CAAC;IACTP,GAAG,CAACQ,eAAe,CAACT,GAAG,CAAC;EAC1B;EAEA,OAAOT,MAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}