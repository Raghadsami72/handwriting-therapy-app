{"ast":null,"code":"// agents/tracking_agent/metrics_calculator.js\n\nexport function calculateMetrics(strokes) {\n  if (strokes.length < 2) {\n    const avgPressure = strokes.length === 1 ? strokes[0].pressure : 0;\n    return {\n      avgSpeed: 0,\n      avgPressure: avgPressure,\n      totalStrokes: strokes.length,\n      speedVariance: 0\n    };\n  }\n  let totalDistance = 0;\n  let totalTime = 0;\n  let pressures = [strokes[0].pressure];\n  for (let i = 1; i < strokes.length; i++) {\n    const dx = strokes[i].x - strokes[i - 1].x;\n    const dy = strokes[i].y - strokes[i - 1].y;\n    const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\n    if (dt > 0) {\n      totalDistance += Math.sqrt(dx * dx + dy * dy);\n      totalTime += dt;\n    }\n    pressures.push(strokes[i].pressure);\n  }\n  const avgSpeed = totalTime > 0 ? totalDistance / (totalTime / 1000) : 0;\n  const avgPressure = pressures.reduce((a, b) => a + b, 0) / pressures.length;\n  const speedVariance = calculateSpeedVariance(strokes);\n  return {\n    avgSpeed: avgSpeed,\n    avgPressure: avgPressure,\n    totalStrokes: strokes.length,\n    speedVariance: speedVariance\n  };\n}\n\n// ðŸŒŸ New function for advanced tracking!\nexport function calculateInstantaneousSpeeds(strokes) {\n  if (strokes.length < 2) return [];\n  const speeds = [];\n  for (let i = 1; i < strokes.length; i++) {\n    const dx = strokes[i].x - strokes[i - 1].x;\n    const dy = strokes[i].y - strokes[i - 1].y;\n    const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\n    if (dt > 0) {\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const speed = distance / (dt / 1000); // pixels per second\n      speeds.push(speed);\n    }\n  }\n  return speeds; // array of instantaneous speeds\n}\n\n// Calculates the variance of instantaneous writing speeds for stability analysis.\n// Variance is the average of the squared differences from the mean speed.\nexport function calculateSpeedVariance(strokes) {\n  const speeds = calculateInstantaneousSpeeds(strokes);\n  if (speeds.length < 2) return 0; // Ensure there is enough data\n\n  const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;\n  const variance = speeds.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / speeds.length;\n  return variance;\n}","map":{"version":3,"names":["calculateMetrics","strokes","length","avgPressure","pressure","avgSpeed","totalStrokes","speedVariance","totalDistance","totalTime","pressures","i","dx","x","dy","y","dt","timestamp","Math","sqrt","push","reduce","a","b","calculateSpeedVariance","calculateInstantaneousSpeeds","speeds","distance","speed","avg","variance","sum","val","pow"],"sources":["C:/Users/DELL/Desktop/HandwritingTherapyApp/frontend/src/agents/tracking_agent/metrics_calculator.js"],"sourcesContent":["// agents/tracking_agent/metrics_calculator.js\r\n\r\n\r\nexport function calculateMetrics(strokes) {\r\n  if (strokes.length < 2) {\r\n    const avgPressure = strokes.length === 1 ? strokes[0].pressure : 0;\r\n    return {\r\n      avgSpeed: 0,\r\n      avgPressure: avgPressure,\r\n      totalStrokes: strokes.length,\r\n      speedVariance: 0,\r\n    };\r\n  }\r\n\r\n  let totalDistance = 0;\r\n  let totalTime = 0;\r\n  let pressures = [strokes[0].pressure];\r\n\r\n  for (let i = 1; i < strokes.length; i++) {\r\n    const dx = strokes[i].x - strokes[i - 1].x;\r\n    const dy = strokes[i].y - strokes[i - 1].y;\r\n    const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\r\n\r\n    if (dt > 0) {\r\n      totalDistance += Math.sqrt(dx * dx + dy * dy);\r\n      totalTime += dt;\r\n    }\r\n\r\n    pressures.push(strokes[i].pressure);\r\n  }\r\n\r\n  const avgSpeed = totalTime > 0 ? (totalDistance / (totalTime / 1000)) : 0;\r\n  const avgPressure = pressures.reduce((a, b) => a + b, 0) / pressures.length;\r\n  const speedVariance = calculateSpeedVariance(strokes);\r\n\r\n  return {\r\n    avgSpeed: avgSpeed,\r\n    avgPressure: avgPressure,\r\n    totalStrokes: strokes.length,\r\n    speedVariance: speedVariance,\r\n  };\r\n}\r\n\r\n  \r\n  // ðŸŒŸ New function for advanced tracking!\r\n  export function calculateInstantaneousSpeeds(strokes) {\r\n    if (strokes.length < 2) return [];\r\n  \r\n    const speeds = [];\r\n  \r\n    for (let i = 1; i < strokes.length; i++) {\r\n      const dx = strokes[i].x - strokes[i - 1].x;\r\n      const dy = strokes[i].y - strokes[i - 1].y;\r\n      const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\r\n  \r\n      if (dt > 0) {\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n        const speed = distance / (dt / 1000); // pixels per second\r\n        speeds.push(speed);\r\n      }\r\n    }\r\n  \r\n    return speeds;  // array of instantaneous speeds\r\n  }\r\n\r\n  // Calculates the variance of instantaneous writing speeds for stability analysis.\r\n// Variance is the average of the squared differences from the mean speed.\r\nexport function calculateSpeedVariance(strokes) {\r\n    const speeds = calculateInstantaneousSpeeds(strokes);\r\n    if (speeds.length < 2) return 0; // Ensure there is enough data\r\n  \r\n    const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;\r\n    const variance = speeds.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / speeds.length;\r\n  \r\n    return variance;\r\n  }\r\n\r\n  \r\n  "],"mappings":"AAAA;;AAGA,OAAO,SAASA,gBAAgBA,CAACC,OAAO,EAAE;EACxC,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;IACtB,MAAMC,WAAW,GAAGF,OAAO,CAACC,MAAM,KAAK,CAAC,GAAGD,OAAO,CAAC,CAAC,CAAC,CAACG,QAAQ,GAAG,CAAC;IAClE,OAAO;MACLC,QAAQ,EAAE,CAAC;MACXF,WAAW,EAAEA,WAAW;MACxBG,YAAY,EAAEL,OAAO,CAACC,MAAM;MAC5BK,aAAa,EAAE;IACjB,CAAC;EACH;EAEA,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,SAAS,GAAG,CAACT,OAAO,CAAC,CAAC,CAAC,CAACG,QAAQ,CAAC;EAErC,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;IACvC,MAAMC,EAAE,GAAGX,OAAO,CAACU,CAAC,CAAC,CAACE,CAAC,GAAGZ,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACE,CAAC;IAC1C,MAAMC,EAAE,GAAGb,OAAO,CAACU,CAAC,CAAC,CAACI,CAAC,GAAGd,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACI,CAAC;IAC1C,MAAMC,EAAE,GAAGf,OAAO,CAACU,CAAC,CAAC,CAACM,SAAS,GAAGhB,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACM,SAAS;IAE1D,IAAID,EAAE,GAAG,CAAC,EAAE;MACVR,aAAa,IAAIU,IAAI,CAACC,IAAI,CAACP,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;MAC7CL,SAAS,IAAIO,EAAE;IACjB;IAEAN,SAAS,CAACU,IAAI,CAACnB,OAAO,CAACU,CAAC,CAAC,CAACP,QAAQ,CAAC;EACrC;EAEA,MAAMC,QAAQ,GAAGI,SAAS,GAAG,CAAC,GAAID,aAAa,IAAIC,SAAS,GAAG,IAAI,CAAC,GAAI,CAAC;EACzE,MAAMN,WAAW,GAAGO,SAAS,CAACW,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGb,SAAS,CAACR,MAAM;EAC3E,MAAMK,aAAa,GAAGiB,sBAAsB,CAACvB,OAAO,CAAC;EAErD,OAAO;IACLI,QAAQ,EAAEA,QAAQ;IAClBF,WAAW,EAAEA,WAAW;IACxBG,YAAY,EAAEL,OAAO,CAACC,MAAM;IAC5BK,aAAa,EAAEA;EACjB,CAAC;AACH;;AAGE;AACA,OAAO,SAASkB,4BAA4BA,CAACxB,OAAO,EAAE;EACpD,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE,OAAO,EAAE;EAEjC,MAAMwB,MAAM,GAAG,EAAE;EAEjB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;IACvC,MAAMC,EAAE,GAAGX,OAAO,CAACU,CAAC,CAAC,CAACE,CAAC,GAAGZ,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACE,CAAC;IAC1C,MAAMC,EAAE,GAAGb,OAAO,CAACU,CAAC,CAAC,CAACI,CAAC,GAAGd,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACI,CAAC;IAC1C,MAAMC,EAAE,GAAGf,OAAO,CAACU,CAAC,CAAC,CAACM,SAAS,GAAGhB,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACM,SAAS;IAE1D,IAAID,EAAE,GAAG,CAAC,EAAE;MACV,MAAMW,QAAQ,GAAGT,IAAI,CAACC,IAAI,CAACP,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;MAC7C,MAAMc,KAAK,GAAGD,QAAQ,IAAIX,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;MACtCU,MAAM,CAACN,IAAI,CAACQ,KAAK,CAAC;IACpB;EACF;EAEA,OAAOF,MAAM,CAAC,CAAE;AAClB;;AAEA;AACF;AACA,OAAO,SAASF,sBAAsBA,CAACvB,OAAO,EAAE;EAC5C,MAAMyB,MAAM,GAAGD,4BAA4B,CAACxB,OAAO,CAAC;EACpD,IAAIyB,MAAM,CAACxB,MAAM,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;;EAEjC,MAAM2B,GAAG,GAAGH,MAAM,CAACL,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGG,MAAM,CAACxB,MAAM;EAC7D,MAAM4B,QAAQ,GAAGJ,MAAM,CAACL,MAAM,CAAC,CAACU,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGb,IAAI,CAACe,GAAG,CAACD,GAAG,GAAGH,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGH,MAAM,CAACxB,MAAM;EAE7F,OAAO4B,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}