{"ast":null,"code":"// agents/tracking_agent/metrics_calculator.js\n\nexport function calculateMetrics(strokes) {\n  if (strokes.length < 2) {\n    const avgPressure = strokes.length === 1 ? strokes[0].pressure : 0;\n    return {\n      avgSpeed: 0,\n      avgPressure: avgPressure,\n      totalStrokes: strokes.length,\n      speedVariance: 0\n    };\n  }\n  let totalDistance = 0;\n  let totalTime = 0;\n  let pressures = [strokes[0].pressure];\n  for (let i = 1; i < strokes.length; i++) {\n    const dx = strokes[i].x - strokes[i - 1].x;\n    const dy = strokes[i].y - strokes[i - 1].y;\n    const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\n    if (dt > 0) {\n      totalDistance += Math.sqrt(dx * dx + dy * dy);\n      totalTime += dt;\n    }\n    pressures.push(strokes[i].pressure);\n  }\n  const avgSpeed = totalTime > 0 ? totalDistance / (totalTime / 1000) : 0;\n  const avgPressure = pressures.reduce((a, b) => a + b, 0) / pressures.length;\n  const speedVariance = calculateSpeedVariance(strokes);\n  return {\n    avgSpeed: avgSpeed,\n    avgPressure: avgPressure,\n    totalStrokes: strokes.length,\n    speedVariance: speedVariance\n  };\n}\n\n// Calculates instantaneous speeds between consecutive points in the stroke data.\nexport function calculateInstantaneousSpeeds(strokes) {\n  if (strokes.length < 2) return [];\n  const speeds = [];\n  for (let i = 1; i < strokes.length; i++) {\n    const dx = strokes[i].x - strokes[i - 1].x;\n    const dy = strokes[i].y - strokes[i - 1].y;\n    const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\n    if (dt > 0) {\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      const speed = distance / (dt / 1000); // pixels per second\n      speeds.push(speed);\n    }\n  }\n  return speeds; // array of instantaneous speeds\n}\n\n// Calculates the variance of instantaneous writing speeds for stability analysis.\n// Variance is the average of the squared differences from the mean speed.\nexport function calculateSpeedVariance(strokes) {\n  const speeds = calculateInstantaneousSpeeds(strokes);\n  if (speeds.length < 2) return 0; // Ensure there is enough data\n\n  const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;\n  const variance = speeds.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / speeds.length;\n  return variance;\n}\n\n/**\r\n * Analyze stroke speed from a sequence of stroke points.\r\n * @param {Array} strokes - [{x, y, pressure, timestamp}, ...]\r\n * @returns {Object} { averageSpeed, maxSpeed, minSpeed, totalLength }\r\n */\nexport function analyzeStrokeSpeed(strokes) {\n  if (!strokes || strokes.length < 2) return null;\n  let totalDistance = 0;\n  let speeds = [];\n  for (let i = 1; i < strokes.length; i++) {\n    const dx = strokes[i].x - strokes[i - 1].x;\n    const dy = strokes[i].y - strokes[i - 1].y;\n    const dt = (strokes[i].timestamp - strokes[i - 1].timestamp) / 1000;\n    if (dt <= 0) continue;\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    const speed = distance / dt;\n    totalDistance += distance;\n    speeds.push(speed);\n  }\n  const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;\n  const maxSpeed = Math.max(...speeds);\n  const minSpeed = Math.min(...speeds);\n  return {\n    averageSpeed,\n    maxSpeed,\n    minSpeed,\n    totalLength: totalDistance\n  };\n}\n\n/**\r\n * Detect micrographia by analyzing size shrinkage over time.\r\n * @param {Array} strokes\r\n * @returns {Object} { shrinkRatio, segmentSizes }\r\n */\nexport function detectMicrographia(strokes) {\n  if (!strokes || strokes.length < 10) return null;\n  const segmentCount = 5;\n  const segmentSize = Math.floor(strokes.length / segmentCount);\n  const segmentSizes = [];\n  for (let i = 0; i < segmentCount; i++) {\n    const segment = strokes.slice(i * segmentSize, (i + 1) * segmentSize);\n    const xs = segment.map(p => p.x);\n    const ys = segment.map(p => p.y);\n    const width = Math.max(...xs) - Math.min(...xs);\n    const height = Math.max(...ys) - Math.min(...ys);\n    segmentSizes.push(Math.sqrt(width * width + height * height));\n  }\n  const shrinkRatio = segmentSizes[segmentSizes.length - 1] / segmentSizes[0];\n  return {\n    shrinkRatio,\n    segmentSizes\n  };\n}\n\n/**\r\n * Detect tremor by identifying high-frequency fluctuations.\r\n * @param {Array} strokes\r\n * @returns {Object} { tremorScore, highFreqSegments }\r\n */\nexport function detectTremor(strokes) {\n  if (!strokes || strokes.length < 3) return null;\n  const deviations = [];\n  const highFreqSegments = [];\n  for (let i = 1; i < strokes.length - 1; i++) {\n    const prev = strokes[i - 1];\n    const curr = strokes[i];\n    const next = strokes[i + 1];\n    const dx1 = curr.x - prev.x;\n    const dy1 = curr.y - prev.y;\n    const dx2 = next.x - curr.x;\n    const dy2 = next.y - curr.y;\n    const angle1 = Math.atan2(dy1, dx1);\n    const angle2 = Math.atan2(dy2, dx2);\n    const delta = Math.abs(angle2 - angle1);\n    deviations.push(delta);\n    if (delta > 0.5) highFreqSegments.push(curr);\n  }\n  const tremorScore = deviations.reduce((a, b) => a + b, 0) / deviations.length;\n  return {\n    tremorScore,\n    highFreqSegments\n  };\n}","map":{"version":3,"names":["calculateMetrics","strokes","length","avgPressure","pressure","avgSpeed","totalStrokes","speedVariance","totalDistance","totalTime","pressures","i","dx","x","dy","y","dt","timestamp","Math","sqrt","push","reduce","a","b","calculateSpeedVariance","calculateInstantaneousSpeeds","speeds","distance","speed","avg","variance","sum","val","pow","analyzeStrokeSpeed","averageSpeed","maxSpeed","max","minSpeed","min","totalLength","detectMicrographia","segmentCount","segmentSize","floor","segmentSizes","segment","slice","xs","map","p","ys","width","height","shrinkRatio","detectTremor","deviations","highFreqSegments","prev","curr","next","dx1","dy1","dx2","dy2","angle1","atan2","angle2","delta","abs","tremorScore"],"sources":["C:/Users/DELL/Desktop/HandwritingTherapyApp/frontend/src/agents/tracking_agent/metrics_calculator.js"],"sourcesContent":["// agents/tracking_agent/metrics_calculator.js\r\n\r\n\r\nexport function calculateMetrics(strokes) {\r\n  if (strokes.length < 2) {\r\n    const avgPressure = strokes.length === 1 ? strokes[0].pressure : 0;\r\n    return {\r\n      avgSpeed: 0,\r\n      avgPressure: avgPressure,\r\n      totalStrokes: strokes.length,\r\n      speedVariance: 0,\r\n    };\r\n  }\r\n\r\n  let totalDistance = 0;\r\n  let totalTime = 0;\r\n  let pressures = [strokes[0].pressure];\r\n\r\n  for (let i = 1; i < strokes.length; i++) {\r\n    const dx = strokes[i].x - strokes[i - 1].x;\r\n    const dy = strokes[i].y - strokes[i - 1].y;\r\n    const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\r\n\r\n    if (dt > 0) {\r\n      totalDistance += Math.sqrt(dx * dx + dy * dy);\r\n      totalTime += dt;\r\n    }\r\n\r\n    pressures.push(strokes[i].pressure);\r\n  }\r\n\r\n  const avgSpeed = totalTime > 0 ? (totalDistance / (totalTime / 1000)) : 0;\r\n  const avgPressure = pressures.reduce((a, b) => a + b, 0) / pressures.length;\r\n  const speedVariance = calculateSpeedVariance(strokes);\r\n\r\n  return {\r\n    avgSpeed: avgSpeed,\r\n    avgPressure: avgPressure,\r\n    totalStrokes: strokes.length,\r\n    speedVariance: speedVariance,\r\n  };\r\n}\r\n\r\n  // Calculates instantaneous speeds between consecutive points in the stroke data.\r\n  export function calculateInstantaneousSpeeds(strokes) {\r\n    if (strokes.length < 2) return [];\r\n  \r\n    const speeds = [];\r\n  \r\n    for (let i = 1; i < strokes.length; i++) {\r\n      const dx = strokes[i].x - strokes[i - 1].x;\r\n      const dy = strokes[i].y - strokes[i - 1].y;\r\n      const dt = strokes[i].timestamp - strokes[i - 1].timestamp;\r\n  \r\n      if (dt > 0) {\r\n        const distance = Math.sqrt(dx * dx + dy * dy);\r\n        const speed = distance / (dt / 1000); // pixels per second\r\n        speeds.push(speed);\r\n      }\r\n    }\r\n  \r\n    return speeds;  // array of instantaneous speeds\r\n  }\r\n\r\n  // Calculates the variance of instantaneous writing speeds for stability analysis.\r\n// Variance is the average of the squared differences from the mean speed.\r\nexport function calculateSpeedVariance(strokes) {\r\n    const speeds = calculateInstantaneousSpeeds(strokes);\r\n    if (speeds.length < 2) return 0; // Ensure there is enough data\r\n  \r\n    const avg = speeds.reduce((a, b) => a + b, 0) / speeds.length;\r\n    const variance = speeds.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / speeds.length;\r\n  \r\n    return variance;\r\n  }\r\n\r\n/**\r\n * Analyze stroke speed from a sequence of stroke points.\r\n * @param {Array} strokes - [{x, y, pressure, timestamp}, ...]\r\n * @returns {Object} { averageSpeed, maxSpeed, minSpeed, totalLength }\r\n */\r\nexport function analyzeStrokeSpeed(strokes) {\r\n  if (!strokes || strokes.length < 2) return null;\r\n\r\n  let totalDistance = 0;\r\n  let speeds = [];\r\n\r\n  for (let i = 1; i < strokes.length; i++) {\r\n    const dx = strokes[i].x - strokes[i - 1].x;\r\n    const dy = strokes[i].y - strokes[i - 1].y;\r\n    const dt = (strokes[i].timestamp - strokes[i - 1].timestamp) / 1000;\r\n\r\n    if (dt <= 0) continue;\r\n\r\n    const distance = Math.sqrt(dx * dx + dy * dy);\r\n    const speed = distance / dt;\r\n\r\n    totalDistance += distance;\r\n    speeds.push(speed);\r\n  }\r\n\r\n  const averageSpeed = speeds.reduce((a, b) => a + b, 0) / speeds.length;\r\n  const maxSpeed = Math.max(...speeds);\r\n  const minSpeed = Math.min(...speeds);\r\n\r\n  return { averageSpeed, maxSpeed, minSpeed, totalLength: totalDistance };\r\n}\r\n\r\n/**\r\n * Detect micrographia by analyzing size shrinkage over time.\r\n * @param {Array} strokes\r\n * @returns {Object} { shrinkRatio, segmentSizes }\r\n */\r\nexport function detectMicrographia(strokes) {\r\n  if (!strokes || strokes.length < 10) return null;\r\n\r\n  const segmentCount = 5;\r\n  const segmentSize = Math.floor(strokes.length / segmentCount);\r\n  const segmentSizes = [];\r\n\r\n  for (let i = 0; i < segmentCount; i++) {\r\n    const segment = strokes.slice(i * segmentSize, (i + 1) * segmentSize);\r\n    const xs = segment.map(p => p.x);\r\n    const ys = segment.map(p => p.y);\r\n    const width = Math.max(...xs) - Math.min(...xs);\r\n    const height = Math.max(...ys) - Math.min(...ys);\r\n    segmentSizes.push(Math.sqrt(width * width + height * height));\r\n  }\r\n\r\n  const shrinkRatio = segmentSizes[segmentSizes.length - 1] / segmentSizes[0];\r\n\r\n  return { shrinkRatio, segmentSizes };\r\n}\r\n\r\n/**\r\n * Detect tremor by identifying high-frequency fluctuations.\r\n * @param {Array} strokes\r\n * @returns {Object} { tremorScore, highFreqSegments }\r\n */\r\nexport function detectTremor(strokes) {\r\n  if (!strokes || strokes.length < 3) return null;\r\n\r\n  const deviations = [];\r\n  const highFreqSegments = [];\r\n\r\n  for (let i = 1; i < strokes.length - 1; i++) {\r\n    const prev = strokes[i - 1];\r\n    const curr = strokes[i];\r\n    const next = strokes[i + 1];\r\n\r\n    const dx1 = curr.x - prev.x;\r\n    const dy1 = curr.y - prev.y;\r\n    const dx2 = next.x - curr.x;\r\n    const dy2 = next.y - curr.y;\r\n\r\n    const angle1 = Math.atan2(dy1, dx1);\r\n    const angle2 = Math.atan2(dy2, dx2);\r\n    const delta = Math.abs(angle2 - angle1);\r\n\r\n    deviations.push(delta);\r\n    if (delta > 0.5) highFreqSegments.push(curr);\r\n  }\r\n\r\n  const tremorScore = deviations.reduce((a, b) => a + b, 0) / deviations.length;\r\n\r\n  return { tremorScore, highFreqSegments };\r\n}\r\n"],"mappings":"AAAA;;AAGA,OAAO,SAASA,gBAAgBA,CAACC,OAAO,EAAE;EACxC,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE;IACtB,MAAMC,WAAW,GAAGF,OAAO,CAACC,MAAM,KAAK,CAAC,GAAGD,OAAO,CAAC,CAAC,CAAC,CAACG,QAAQ,GAAG,CAAC;IAClE,OAAO;MACLC,QAAQ,EAAE,CAAC;MACXF,WAAW,EAAEA,WAAW;MACxBG,YAAY,EAAEL,OAAO,CAACC,MAAM;MAC5BK,aAAa,EAAE;IACjB,CAAC;EACH;EAEA,IAAIC,aAAa,GAAG,CAAC;EACrB,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,SAAS,GAAG,CAACT,OAAO,CAAC,CAAC,CAAC,CAACG,QAAQ,CAAC;EAErC,KAAK,IAAIO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;IACvC,MAAMC,EAAE,GAAGX,OAAO,CAACU,CAAC,CAAC,CAACE,CAAC,GAAGZ,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACE,CAAC;IAC1C,MAAMC,EAAE,GAAGb,OAAO,CAACU,CAAC,CAAC,CAACI,CAAC,GAAGd,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACI,CAAC;IAC1C,MAAMC,EAAE,GAAGf,OAAO,CAACU,CAAC,CAAC,CAACM,SAAS,GAAGhB,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACM,SAAS;IAE1D,IAAID,EAAE,GAAG,CAAC,EAAE;MACVR,aAAa,IAAIU,IAAI,CAACC,IAAI,CAACP,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;MAC7CL,SAAS,IAAIO,EAAE;IACjB;IAEAN,SAAS,CAACU,IAAI,CAACnB,OAAO,CAACU,CAAC,CAAC,CAACP,QAAQ,CAAC;EACrC;EAEA,MAAMC,QAAQ,GAAGI,SAAS,GAAG,CAAC,GAAID,aAAa,IAAIC,SAAS,GAAG,IAAI,CAAC,GAAI,CAAC;EACzE,MAAMN,WAAW,GAAGO,SAAS,CAACW,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGb,SAAS,CAACR,MAAM;EAC3E,MAAMK,aAAa,GAAGiB,sBAAsB,CAACvB,OAAO,CAAC;EAErD,OAAO;IACLI,QAAQ,EAAEA,QAAQ;IAClBF,WAAW,EAAEA,WAAW;IACxBG,YAAY,EAAEL,OAAO,CAACC,MAAM;IAC5BK,aAAa,EAAEA;EACjB,CAAC;AACH;;AAEE;AACA,OAAO,SAASkB,4BAA4BA,CAACxB,OAAO,EAAE;EACpD,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE,OAAO,EAAE;EAEjC,MAAMwB,MAAM,GAAG,EAAE;EAEjB,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;IACvC,MAAMC,EAAE,GAAGX,OAAO,CAACU,CAAC,CAAC,CAACE,CAAC,GAAGZ,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACE,CAAC;IAC1C,MAAMC,EAAE,GAAGb,OAAO,CAACU,CAAC,CAAC,CAACI,CAAC,GAAGd,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACI,CAAC;IAC1C,MAAMC,EAAE,GAAGf,OAAO,CAACU,CAAC,CAAC,CAACM,SAAS,GAAGhB,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACM,SAAS;IAE1D,IAAID,EAAE,GAAG,CAAC,EAAE;MACV,MAAMW,QAAQ,GAAGT,IAAI,CAACC,IAAI,CAACP,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;MAC7C,MAAMc,KAAK,GAAGD,QAAQ,IAAIX,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC;MACtCU,MAAM,CAACN,IAAI,CAACQ,KAAK,CAAC;IACpB;EACF;EAEA,OAAOF,MAAM,CAAC,CAAE;AAClB;;AAEA;AACF;AACA,OAAO,SAASF,sBAAsBA,CAACvB,OAAO,EAAE;EAC5C,MAAMyB,MAAM,GAAGD,4BAA4B,CAACxB,OAAO,CAAC;EACpD,IAAIyB,MAAM,CAACxB,MAAM,GAAG,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;;EAEjC,MAAM2B,GAAG,GAAGH,MAAM,CAACL,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGG,MAAM,CAACxB,MAAM;EAC7D,MAAM4B,QAAQ,GAAGJ,MAAM,CAACL,MAAM,CAAC,CAACU,GAAG,EAAEC,GAAG,KAAKD,GAAG,GAAGb,IAAI,CAACe,GAAG,CAACD,GAAG,GAAGH,GAAG,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGH,MAAM,CAACxB,MAAM;EAE7F,OAAO4B,QAAQ;AACjB;;AAEF;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,kBAAkBA,CAACjC,OAAO,EAAE;EAC1C,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI;EAE/C,IAAIM,aAAa,GAAG,CAAC;EACrB,IAAIkB,MAAM,GAAG,EAAE;EAEf,KAAK,IAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACC,MAAM,EAAES,CAAC,EAAE,EAAE;IACvC,MAAMC,EAAE,GAAGX,OAAO,CAACU,CAAC,CAAC,CAACE,CAAC,GAAGZ,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACE,CAAC;IAC1C,MAAMC,EAAE,GAAGb,OAAO,CAACU,CAAC,CAAC,CAACI,CAAC,GAAGd,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACI,CAAC;IAC1C,MAAMC,EAAE,GAAG,CAACf,OAAO,CAACU,CAAC,CAAC,CAACM,SAAS,GAAGhB,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC,CAACM,SAAS,IAAI,IAAI;IAEnE,IAAID,EAAE,IAAI,CAAC,EAAE;IAEb,MAAMW,QAAQ,GAAGT,IAAI,CAACC,IAAI,CAACP,EAAE,GAAGA,EAAE,GAAGE,EAAE,GAAGA,EAAE,CAAC;IAC7C,MAAMc,KAAK,GAAGD,QAAQ,GAAGX,EAAE;IAE3BR,aAAa,IAAImB,QAAQ;IACzBD,MAAM,CAACN,IAAI,CAACQ,KAAK,CAAC;EACpB;EAEA,MAAMO,YAAY,GAAGT,MAAM,CAACL,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGG,MAAM,CAACxB,MAAM;EACtE,MAAMkC,QAAQ,GAAGlB,IAAI,CAACmB,GAAG,CAAC,GAAGX,MAAM,CAAC;EACpC,MAAMY,QAAQ,GAAGpB,IAAI,CAACqB,GAAG,CAAC,GAAGb,MAAM,CAAC;EAEpC,OAAO;IAAES,YAAY;IAAEC,QAAQ;IAAEE,QAAQ;IAAEE,WAAW,EAAEhC;EAAc,CAAC;AACzE;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiC,kBAAkBA,CAACxC,OAAO,EAAE;EAC1C,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACC,MAAM,GAAG,EAAE,EAAE,OAAO,IAAI;EAEhD,MAAMwC,YAAY,GAAG,CAAC;EACtB,MAAMC,WAAW,GAAGzB,IAAI,CAAC0B,KAAK,CAAC3C,OAAO,CAACC,MAAM,GAAGwC,YAAY,CAAC;EAC7D,MAAMG,YAAY,GAAG,EAAE;EAEvB,KAAK,IAAIlC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG+B,YAAY,EAAE/B,CAAC,EAAE,EAAE;IACrC,MAAMmC,OAAO,GAAG7C,OAAO,CAAC8C,KAAK,CAACpC,CAAC,GAAGgC,WAAW,EAAE,CAAChC,CAAC,GAAG,CAAC,IAAIgC,WAAW,CAAC;IACrE,MAAMK,EAAE,GAAGF,OAAO,CAACG,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACrC,CAAC,CAAC;IAChC,MAAMsC,EAAE,GAAGL,OAAO,CAACG,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACnC,CAAC,CAAC;IAChC,MAAMqC,KAAK,GAAGlC,IAAI,CAACmB,GAAG,CAAC,GAAGW,EAAE,CAAC,GAAG9B,IAAI,CAACqB,GAAG,CAAC,GAAGS,EAAE,CAAC;IAC/C,MAAMK,MAAM,GAAGnC,IAAI,CAACmB,GAAG,CAAC,GAAGc,EAAE,CAAC,GAAGjC,IAAI,CAACqB,GAAG,CAAC,GAAGY,EAAE,CAAC;IAChDN,YAAY,CAACzB,IAAI,CAACF,IAAI,CAACC,IAAI,CAACiC,KAAK,GAAGA,KAAK,GAAGC,MAAM,GAAGA,MAAM,CAAC,CAAC;EAC/D;EAEA,MAAMC,WAAW,GAAGT,YAAY,CAACA,YAAY,CAAC3C,MAAM,GAAG,CAAC,CAAC,GAAG2C,YAAY,CAAC,CAAC,CAAC;EAE3E,OAAO;IAAES,WAAW;IAAET;EAAa,CAAC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,YAAYA,CAACtD,OAAO,EAAE;EACpC,IAAI,CAACA,OAAO,IAAIA,OAAO,CAACC,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI;EAE/C,MAAMsD,UAAU,GAAG,EAAE;EACrB,MAAMC,gBAAgB,GAAG,EAAE;EAE3B,KAAK,IAAI9C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,OAAO,CAACC,MAAM,GAAG,CAAC,EAAES,CAAC,EAAE,EAAE;IAC3C,MAAM+C,IAAI,GAAGzD,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC;IAC3B,MAAMgD,IAAI,GAAG1D,OAAO,CAACU,CAAC,CAAC;IACvB,MAAMiD,IAAI,GAAG3D,OAAO,CAACU,CAAC,GAAG,CAAC,CAAC;IAE3B,MAAMkD,GAAG,GAAGF,IAAI,CAAC9C,CAAC,GAAG6C,IAAI,CAAC7C,CAAC;IAC3B,MAAMiD,GAAG,GAAGH,IAAI,CAAC5C,CAAC,GAAG2C,IAAI,CAAC3C,CAAC;IAC3B,MAAMgD,GAAG,GAAGH,IAAI,CAAC/C,CAAC,GAAG8C,IAAI,CAAC9C,CAAC;IAC3B,MAAMmD,GAAG,GAAGJ,IAAI,CAAC7C,CAAC,GAAG4C,IAAI,CAAC5C,CAAC;IAE3B,MAAMkD,MAAM,GAAG/C,IAAI,CAACgD,KAAK,CAACJ,GAAG,EAAED,GAAG,CAAC;IACnC,MAAMM,MAAM,GAAGjD,IAAI,CAACgD,KAAK,CAACF,GAAG,EAAED,GAAG,CAAC;IACnC,MAAMK,KAAK,GAAGlD,IAAI,CAACmD,GAAG,CAACF,MAAM,GAAGF,MAAM,CAAC;IAEvCT,UAAU,CAACpC,IAAI,CAACgD,KAAK,CAAC;IACtB,IAAIA,KAAK,GAAG,GAAG,EAAEX,gBAAgB,CAACrC,IAAI,CAACuC,IAAI,CAAC;EAC9C;EAEA,MAAMW,WAAW,GAAGd,UAAU,CAACnC,MAAM,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,EAAE,CAAC,CAAC,GAAGiC,UAAU,CAACtD,MAAM;EAE7E,OAAO;IAAEoE,WAAW;IAAEb;EAAiB,CAAC;AAC1C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}